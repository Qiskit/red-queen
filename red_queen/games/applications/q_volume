import os
import math
import pytest
from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister
from applications import backends, run_qiskit_circuit


QASM_DIR = os.path.join(os.path.dirname(os.path.abspath(__file__)), "qasm")
SECRET_PROBABILITY= 
NUMQUBITS = 

#Import Qiskit classes
from qiskit import assemble, transpile
from qiskit.providers.aer.noise import NoiseModel
from qiskit.providers.aer.noise.errors.standard_errors import depolarizing_error, thermal_relaxation_error
from qiskit import Aer, transpile
from qiskit.visualization import plot_histogram


#Import the qv function
from qiskit.circuit.library import QuantumVolume
from qiskit.quantum_info import random_unitary
from random import shuffle
import numpy as np
import copy
import itertools
import warnings

def qv_circuits(qubit_lists, ntrials=1,qr=None, cr=None, seed=None):
    """
    Return a list of square quantum volume circuits (depth=width)

    The qubit_lists is specified as a list of qubit lists. For each
    set of qubits, circuits the depth as the number of qubits in the list
    are generated

    Args:
        qubit_lists (list): list of list of qubits to apply qv circuits to. Assume
            the list is ordered in increasing number of qubits
        ntrials (int): number of random iterations
        qr (QuantumRegister): quantum register to act on (if None one is created)
        cr (ClassicalRegister): classical register to measure to (if None one is created)
        seed (int): An optional RNG seed to use for the generated circuit

    Returns:
        tuple: A tuple of the type (``circuits``, ``circuits_nomeas``) wheere:
            ``circuits`` is a list of lists of circuits for the qv sequences
            (separate list for each trial) and `` circuitss_nomeas`` is the
            same circuits but with no measurements for the ideal simulation
    """
    if qr is not None:
        warnings.warn("Passing in a custom quantum register is deprecated and "
                      "will be removed in a future release. This argument "
                      "never had any effect.",
                      DeprecationWarning)

    if cr is not None:
        warnings.warn("Passing in a custom classical register is deprecated "
                      "and will be removed in a future release. This argument "
                      "never had any effect.",
                      DeprecationWarning)
    for qubit_list in qubit_lists:
        count = itertools.count(qubit_list[0])
        for qubit in qubit_list:
            if qubit != next(count):
                warnings.warn("Using a qubit list to map a virtual circuit to "
                              "a physical layout is deprecated and will be "
                              "removed in a future release. Instead use "
                              "''qiskit.transpile' with the "
                              "'initial_layout' parameter",
                              DeprecationWarning)
    depth_list = [len(qubit_list) for qubit_list in qubit_lists]

    if seed:
        rng = np.random.default_rng(seed)
    else:
        _seed = None

    circuits = [[] for e in range(ntrials)]
    circuits_nomeas = [[] for e in range(ntrials)]

    for trial in range(ntrials):
        for depthidx, depth in enumerate(depth_list):
            n_q_max = np.max(qubit_lists[depthidx])
            if seed:
                _seed = rng.integers(1000)
            qv_circ = QuantumVolume(depth, depth, seed=_seed)
            qc2 = copy.deepcopy(qv_circ)
            # TODO: Remove this when we remove support for doing pseudo-layout
            # via qubit lists
            if n_q_max != depth:
                qc = QuantumCircuit(int(n_q_max + 1))
                qc.compose(qv_circ, qubit_lists[depthidx], inplace=True)
            else:
                qc = qv_circ
            qc.measure_active()
            qc.name = 'qv_depth_%d_trial_%d' % (depth, trial)
            qc2.name = qc.name

            circuits_nomeas[trial].append(qc2)
            circuits[trial].append(qc)

    return circuits, circuits_nomeas

def get_heavy_outputs(counts):
    """Extract heavy outputs from counts dict.
    Args:
        counts (dict): Output of `.get_counts()`
    Returns:
        list: All states with measurement probability greater
              than the mean.
    """
    # sort the keys of `counts` by value of counts.get(key)
    sorted_counts = sorted(counts.keys(), key=counts.get)
    # discard results with probability < median
    heavy_outputs = sorted_counts[len(sorted_counts)//2:]
    return heavy_outputs

def check_threshold(nheavies, ncircuits, nshots):
    """Evaluate adjusted threshold inequality for quantum volume.
    Args:
        nheavies (int): Total number of heavy outputs measured from device
        ncircuits (int): Number of different square circuits run on device
        nshots (int): Number of shots per circuit
    Returns:
        Bool:
            True if heavy output probability is > 2/3 with 97% certainty,
            otherwise False
    """
    from numpy import sqrt
    numerator = nheavies - 2*sqrt(nheavies*(nshots-(nheavies/ncircuits)))
    return bool(numerator/(ncircuits*nshots) > 2/3)

def test_qv(device, qubits, ncircuits, nshots):
    """Try to achieve 2**len(qubits) quantum volume on device.
    Args:
        device (qiskit.providers.Backend): Device to test.
        qubits (list(int)): List of qubits to use for test.
        ncircuits (int): Number of unique circuits to generate
                         (should be >100).
        nshots (int): Number of shots per circuit.
    Returns:
        Bool
            True if device passes test, otherwise False.
    """
    # generate set of random circuits
    qv_qc, qv_qc_nomeas = qv_circuits([qubits], ncircuits)
    nheavies = 0  # number of measured heavy outputs

    def get_result(circuit, backend=None):
        if backend is None:  # use simulator
            backend = Aer.get_backend('aer_simulator')
            circuit.save_statevector()
            shots = None
            memory = None
        else:
            shots = nshots
            memory = True
        t_circuit = transpile(circuit, backend)
       
    # 'assemble' is just until mock backends take circuits in 'run'
        
        #from qiskit import assemble
        job = backend.run(t_circuit,
                                   shots=shots,
                                   memory=memory)
        return job.result()

    for circuit in range(ncircuits):
        # simulate circuit
        counts = get_result(qv_qc_nomeas[circuit][0]).get_counts()
        # get heavy outputs from simulated results
        simulated_heavy_outputs = get_heavy_outputs(counts)
        # run circuit on device
        device_result = get_result(qv_qc[circuit][0], device)
        # record whether device result is in the heavy outputs
        for output in device_result.get_memory():
            if output in simulated_heavy_outputs:
                nheavies += 1

    # do statistical check to see if device passes test
    is_pass = check_threshold(nheavies, ncircuits, nshots)
    # calculate percentage of measurements that are heavy outputs
    pho = nheavies*100/(ncircuits * nshots)

    print(f"Quantum Volume: {2**len(qubits)}\n"
          f"Percentage Heavy Outputs: {pho:.1f}%\n"
          f"Passed?: {is_pass}\n")
    return is_pass

# Benchmarking


@pytest.mark.qiskit
@pytest.mark.parametrize("optimization_level", [0, 1, 2, 3])
@pytest.mark.parametrize("backend", backends)
def bench_qiskit_bv(benchmark, optimization_level, backend):
    shots = 65536
    expected_counts = {fraction_bin(SECRET_PROBABILITY): shots}
    benchmark.name = "Quantum Phase Estimation"
    circ = QuantumCircuit.from_qasm_file(os.path.join(QASM_DIR, "qpe.qasm"))
    benchmark.algorithm = f"Optimization level: {optimization_level} on {backend.name()}"
    run_qiskit_circuit(benchmark, circ, backend, optimization_level, shots, expected_counts)


if __name__ == "__main__":
    test_qv(NUMQUBITS, SECRET_PROBABILITY).qasm(
        filename=os.path.join(QASM_DIR, "qpe.qasm")
    )


